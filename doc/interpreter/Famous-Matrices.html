<html lang="en">
<head>
<title>Famous Matrices - Untitled</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Untitled">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Matrix-Manipulation.html#Matrix-Manipulation" title="Matrix Manipulation">
<link rel="prev" href="Special-Utility-Matrices.html#Special-Utility-Matrices" title="Special Utility Matrices">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Famous-Matrices"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="Special-Utility-Matrices.html#Special-Utility-Matrices">Special Utility Matrices</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Matrix-Manipulation.html#Matrix-Manipulation">Matrix Manipulation</a>
<hr>
</div>

<h3 class="section">17.5 Famous Matrices</h3>

<p>The following functions return famous matrix forms.

   <p><a name="doc_002dhadamard"></a>

<div class="defun">
&mdash; Function File:  <b>hadamard</b> (<var>n</var>)<var><a name="index-hadamard-898"></a></var><br>
<blockquote><p>Construct a Hadamard matrix <var>Hn</var> of size <var>n</var>-by-<var>n</var>. The
size <var>n</var> must be of the form <code>2 ^ </code><var>k</var><code> * </code><var>p</var> in which
<var>p</var> is one of 1, 12, 20 or 28. The returned matrix is normalized,
meaning <code>Hn(:,1) == 1</code> and <code>H(1,:) == 1</code>.

        <p>Some of the properties of Hadamard matrices are:

          <ul>
<li><code>kron (</code><var>Hm</var><code>, </code><var>Hn</var><code>)</code> is a Hadamard matrix of size
<var>m</var>-by-<var>n</var>. 
<li><code>Hn * Hn' == </code><var>n</var><code> * eye (</code><var>n</var><code>)</code>. 
<li>The rows of <var>Hn</var> are orthogonal. 
<li><code>det (</code><var>A</var><code>) &lt;= det (</code><var>Hn</var><code>)</code> for all <var>A</var> with
<code>abs (</code><var>A</var><code> (</code><var>i</var><code>, </code><var>j</var><code>)) &lt;= 1</code>. 
<li>Multiply any row or column by -1 and still have a Hadamard matrix. 
</ul>

        </blockquote></div>

   <p><a name="doc_002dhankel"></a>

<div class="defun">
&mdash; Function File:  <b>hankel</b> (<var>c, r</var>)<var><a name="index-hankel-899"></a></var><br>
<blockquote><p>Return the Hankel matrix constructed given the first column <var>c</var>, and
(optionally) the last row <var>r</var>.  If the last element of <var>c</var> is
not the same as the first element of <var>r</var>, the last element of
<var>c</var> is used.  If the second argument is omitted, it is assumed to
be a vector of zeros with the same size as <var>c</var>.

        <p>A Hankel matrix formed from an m-vector <var>c</var>, and an n-vector
<var>r</var>, has the elements

     <pre class="example">          H(i,j) = c(i+j-1),  i+j-1 &lt;= m;
          H(i,j) = r(i+j-m),  otherwise
     </pre>
        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> vander, sylvester_matrix, hilb, invhilb, toeplitz. 
</p></blockquote></div>

   <p><a name="doc_002dhilb"></a>

<div class="defun">
&mdash; Function File:  <b>hilb</b> (<var>n</var>)<var><a name="index-hilb-900"></a></var><br>
<blockquote><p>Return the Hilbert matrix of order <var>n</var>.  The
i, j
element of a Hilbert matrix is defined as

     <pre class="example">          H (i, j) = 1 / (i + j - 1)
     </pre>
        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> hankel, vander, sylvester_matrix, invhilb, toeplitz. 
</p></blockquote></div>

   <p><a name="doc_002dinvhilb"></a>

<div class="defun">
&mdash; Function File:  <b>invhilb</b> (<var>n</var>)<var><a name="index-invhilb-901"></a></var><br>
<blockquote><p>Return the inverse of a Hilbert matrix of order <var>n</var>.  This can be
computed exactly using
     <pre class="example">          
                      (i+j)         /n+i-1\  /n+j-1\   /i+j-2\ 2
           A(i,j) = -1      (i+j-1)(       )(       ) (       )
                                    \ n-j /  \ n-i /   \ i-2 /
          
                  = p(i) p(j) / (i+j-1)
          
     </pre>
        <p>where
     <pre class="example">                       k  /k+n-1\   /n\
              p(k) = -1  (       ) (   )
                          \ k-1 /   \k/
     </pre>
        <p>The validity of this formula can easily be checked by expanding
the binomial coefficients in both formulas as factorials.  It can
be derived more directly via the theory of Cauchy matrices:
see J. W. Demmel, Applied Numerical Linear Algebra, page 92.

        <p>Compare this with the numerical calculation of <code>inverse (hilb (n))</code>,
which suffers from the ill-conditioning of the Hilbert matrix, and the
finite precision of your computer's floating point arithmetic.
        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> hankel, vander, sylvester_matrix, hilb, toeplitz. 
</p></blockquote></div>

   <p><a name="doc_002dmagic"></a>

<div class="defun">
&mdash; Function File:  <b>magic</b> (<var>n</var>)<var><a name="index-magic-902"></a></var><br>
<blockquote>
<p>Create an <var>n</var>-by-<var>n</var> magic square. Note that <code>magic
(</code><var>2</var><code>)</code> is undefined since there is no 2-by-2 magic square.

        </blockquote></div>

   <p><a name="doc_002dpascal"></a>

<div class="defun">
&mdash; Function File:  <b>pascal</b> (<var>n, t</var>)<var><a name="index-pascal-903"></a></var><br>
<blockquote>
<p>Return the Pascal matrix of order <var>n</var> if <var>t</var><code> = 0</code>. 
<var>t</var> defaults to 0. Return lower triangular Cholesky factor of
the Pascal matrix if <var>t</var><code> = 1</code>. This matrix is its own
inverse, that is <code>pascal (</code><var>n</var><code>, 1) ^ 2 == eye (</code><var>n</var><code>)</code>. 
If <var>t</var><code> = 2</code>, return a transposed and  permuted version of
<code>pascal (</code><var>n</var><code>, 1)</code>, which is the cube-root of the identity
matrix. That is <code>pascal (</code><var>n</var><code>, 2) ^ 3 == eye (</code><var>n</var><code>)</code>.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> hankel, vander, sylvester_matrix, hilb, invhilb, toeplitz
          hadamard, wilkinson, compan, rosser. 
</p></blockquote></div>

   <p><a name="doc_002drosser"></a>

<div class="defun">
&mdash; Function File:  <b>rosser</b> ()<var><a name="index-rosser-904"></a></var><br>
<blockquote>
<p>Returns the Rosser matrix. This is a difficult test case used to test
eigenvalue algorithms.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> hankel, vander, sylvester_matrix, hilb, invhilb, toeplitz
          hadamard, wilkinson, compan, pascal. 
</p></blockquote></div>

   <p><a name="doc_002dsylvester_005fmatrix"></a>

<div class="defun">
&mdash; Function File:  <b>sylvester_matrix</b> (<var>k</var>)<var><a name="index-sylvester_005fmatrix-905"></a></var><br>
<blockquote><p>Return the Sylvester matrix of order
n = 2^k.
        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> hankel, vander, hilb, invhilb, toeplitz. 
</p></blockquote></div>

   <p><a name="doc_002dtoeplitz"></a>

<div class="defun">
&mdash; Function File:  <b>toeplitz</b> (<var>c, r</var>)<var><a name="index-toeplitz-906"></a></var><br>
<blockquote><p>Return the Toeplitz matrix constructed given the first column <var>c</var>,
and (optionally) the first row <var>r</var>.  If the first element of <var>c</var>
is not the same as the first element of <var>r</var>, the first element of
<var>c</var> is used.  If the second argument is omitted, the first row is
taken to be the same as the first column.

        <p>A square Toeplitz matrix has the form:

     <pre class="example">          c(0)  r(1)   r(2)  ...  r(n)
          c(1)  c(0)   r(1)  ... r(n-1)
          c(2)  c(1)   c(0)  ... r(n-2)
           .     ,      ,   .      .
           .     ,      ,     .    .
           .     ,      ,       .  .
          c(n) c(n-1) c(n-2) ...  c(0)
     </pre>
        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> hankel, vander, sylvester_matrix, hilb, invhilb. 
</p></blockquote></div>

   <p><a name="doc_002dvander"></a>

<div class="defun">
&mdash; Function File:  <b>vander</b> (<var>c</var>)<var><a name="index-vander-907"></a></var><br>
<blockquote><p>Return the Vandermonde matrix whose next to last column is <var>c</var>.

        <p>A Vandermonde matrix has the form:

     <pre class="example">          c(1)^(n-1) ... c(1)^2  c(1)  1
          c(2)^(n-1) ... c(2)^2  c(2)  1
              .     .      .      .    .
              .       .    .      .    .
              .         .  .      .    .
          c(n)^(n-1) ... c(n)^2  c(n)  1
     </pre>
        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> hankel, sylvester_matrix, hilb, invhilb, toeplitz. 
</p></blockquote></div>

   <p><a name="doc_002dwilkinson"></a>

<div class="defun">
&mdash; Function File:  <b>wilkinson</b> (<var>n</var>)<var><a name="index-wilkinson-908"></a></var><br>
<blockquote>
<p>Return the Wilkinson matrix of order <var>n</var>.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> hankel, vander, sylvester_matrix, hilb, invhilb, toeplitz
          hadamard, rosser, compan, pascal. 
</p></blockquote></div>

<!-- DO NOT EDIT!  Generated automatically by munge-texi. -->
<!-- Copyright (C) 1996, 1997 John W. Eaton -->
<!-- This is part of the Octave manual. -->
<!-- For copying conditions, see the file gpl.texi. -->
</body></html>


<html lang="en">
<head>
<title>Formatted Input - Untitled</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Untitled">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="C_002dStyle-I_002fO-Functions.html#C_002dStyle-I_002fO-Functions" title="C-Style I/O Functions">
<link rel="prev" href="Other-Output-Conversions.html#Other-Output-Conversions" title="Other Output Conversions">
<link rel="next" href="Input-Conversion-Syntax.html#Input-Conversion-Syntax" title="Input Conversion Syntax">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
td,p {
font-family: arial,sans-serif;
color: #000000;
}

body {
  background: white;
  color: #000000;
  font-family: arial,sans-serif;
  font-weight: normal;
  font-size: medium;
  min-width: 500px;
  max-width: 950px;
  margin-left: 3%;
  margin-right: 12%;
}

a:link {
color: #0050fa;
}

a:visited {
color: #1188ff;
}

.code {
margin-left: 30px;
margin-right: 30px;
background-color: #d0d0d0;
color: #000000;
}

/* the navigation choices at the bottom of the page. */

div#nav {
color: #000000;
float: left;
font-family: arial,sans-serif;
font-size: 0.75em;
margin: 1em 0 0 1em;
padding: 0;
position: fixed;
text-align: left;
width: 10em;
}

div#nav a {
background-color: #dde4ff;
border: 1px solid;
border-color: #10a0ff;
display: block;
padding: 0.2em 0.5em 0.2em 0.5em ;
text-decoration: none;
color: #1155dd;
}

div#nav a:hover {
background-color: #f5f5ff;
}

div#nav div#currentnav {
background-color: #ccccdd;
border: solid;
border-left-width: 1px;
border-top-width: 1px;
border-bottom-width: 1px;
border-right-width: 0px;
border-color: #10a0ff;
display: block;
padding: 0.2em 0.5em 0.2em 0.5em ;
text-align: right;
}

/* the page content */

div#content {
  position: relative;
  left: 11em;
  width: 80%;
}

div.section {
  clear: both;
}

/* For all page footers */
div#footer {
clear: both;
font-size: x-small;
text-align: center;
color: #606060;
}

/* the title bar */

div#title {
width: 100%;
clear: both;
}

div#title h1 {
background-color: #ffffff;
border-bottom: 5px solid #33ccff;
font-size: xx-large;
color: #10a0ff;
padding: 0;
margin: 0;
}

/* The blue title bar on non-main pages */

.header {
color: #ffffff;
background-color: #10a0ff;
font-family: arial,sans-serif;
padding: 0;
font-size: medium;
font-weight: bold;
border: 3px solid #10a0ff;
}

/* For the download page */

/* descriptions of versions available */
dt {
font-weight: bold;
}

dd {
font-family: arial,sans-serif;
}

/* Highlighting the code download sections */
.download {
background-color: #d0e0ff;
}

caption {
display: none;
}

th {
text-align: left;
}

/* Changes for Octave Wiki */

h1 {
background-color: #10a0ff;
color: #ffffff;
font-size: xx-large;
padding: 2em;
margin: 8em;
}

h2 {
background-color: #10a0ff;
color: #ffffff;
font-size: 1.2em;
padding: 2px;
margin-top: 5px;
}

h3 {
background-color: #10a0ff;
color: #ffffff;
font-size: 1.1em;
padding: 2px;
margin-top: 5px;
}

h4,h5,h6 {
color: #606060;
font-size: large;
padding: 2px;
margin-top: 5px;
}

/* for links in the header */
h1 a {
color: #ffffff;
}

#im {
float: right;
margin: 10px;
border: 2px solid #000000;
}

#iml {
margin: 10px;
float: right;
border: 2px solid #000000;
clear: right;
}

img.left { float:left; margin:1em; }
img.right { float:right; margin:1em; }
img.middle { text-align:center; margin:1em; }

img.logo { float: right; clear: right; border-style:none; }

pre {
border: #777777 1px solid;
padding: 0.5em;
margin-left: 1em;
margin-right: 2em;
white-space: pre;
background-color: #e6e6e6;
color: black;
}

blockquote.note {
border: #777777 1px solid;
padding: 0.5em;
margin-left: 1em;
margin-right: 2em;
background-color: #e6e6e6;
color: black;
}
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Formatted-Input"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Input-Conversion-Syntax.html#Input-Conversion-Syntax">Input Conversion Syntax</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Other-Output-Conversions.html#Other-Output-Conversions">Other Output Conversions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="C_002dStyle-I_002fO-Functions.html#C_002dStyle-I_002fO-Functions">C-Style I/O Functions</a>
<hr>
</div>

<h4 class="subsection">15.2.11 Formatted Input</h4>

<p>Octave provides the <code>scanf</code>, <code>fscanf</code>, and <code>sscanf</code>
functions to read formatted input.  There are two forms of each of these
functions.  One can be used to extract vectors of data from a file, and
the other is more `C-like'.

   <p><a name="doc_002dfscanf"></a>

<div class="defun">
&mdash; Built-in Function: [<var>val</var>, <var>count</var>] = <b>fscanf</b> (<var>fid, template, size</var>)<var><a name="index-fscanf-703"></a></var><br>
&mdash; Built-in Function: [<var>v1</var>, <var>v2</var>, <small class="dots">...</small>, <var>count</var>] = <b>fscanf</b> (<var>fid, template, "C"</var>)<var><a name="index-fscanf-704"></a></var><br>
<blockquote><p>In the first form, read from <var>fid</var> according to <var>template</var>,
returning the result in the matrix <var>val</var>.

        <p>The optional argument <var>size</var> specifies the amount of data to read
and may be one of

          <dl>
<dt><code>Inf</code><dd>Read as much as possible, returning a column vector.

          <br><dt><var>nr</var><dd>Read up to <var>nr</var> elements, returning a column vector.

          <br><dt><code>[</code><var>nr</var><code>, Inf]</code><dd>Read as much as possible, returning a matrix with <var>nr</var> rows.  If the
number of elements read is not an exact multiple of <var>nr</var>, the last
column is padded with zeros.

          <br><dt><code>[</code><var>nr</var><code>, </code><var>nc</var><code>]</code><dd>Read up to <var>nr</var><code> * </code><var>nc</var> elements, returning a matrix with
<var>nr</var> rows.  If the number of elements read is not an exact multiple
of <var>nr</var>, the last column is padded with zeros. 
</dl>

     <p class="noindent">If <var>size</var> is omitted, a value of <code>Inf</code> is assumed.

        <p>A string is returned if <var>template</var> specifies only character
conversions.

        <p>The number of items successfully read is returned in <var>count</var>.

        <p>In the second form, read from <var>fid</var> according to <var>template</var>,
with each conversion specifier in <var>template</var> corresponding to a
single scalar return value.  This form is more `C-like', and also
compatible with previous versions of Octave.  The number of successful
conversions is returned in <var>count</var>
        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> scanf, sscanf, fread, fprintf. 
</p></blockquote></div>

   <p><a name="doc_002dsscanf"></a>

<div class="defun">
&mdash; Built-in Function: [<var>val</var>, <var>count</var>] = <b>sscanf</b> (<var>string, template, size</var>)<var><a name="index-sscanf-705"></a></var><br>
&mdash; Built-in Function: [<var>v1</var>, <var>v2</var>, <small class="dots">...</small>, <var>count</var>] = <b>sscanf</b> (<var>string, template, "C"</var>)<var><a name="index-sscanf-706"></a></var><br>
<blockquote><p>This is like <code>fscanf</code>, except that the characters are taken from the
string <var>string</var> instead of from a stream.  Reaching the end of the
string is treated as an end-of-file condition.
        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> fscanf, scanf, sprintf. 
</p></blockquote></div>

   <p>Calls to <code>scanf</code> are superficially similar to calls to
<code>printf</code> in that arbitrary arguments are read under the control of
a template string.  While the syntax of the conversion specifications in
the template is very similar to that for <code>printf</code>, the
interpretation of the template is oriented more towards free-format
input and simple pattern matching, rather than fixed-field formatting. 
For example, most <code>scanf</code> conversions skip over any amount of
&ldquo;white space&rdquo; (including spaces, tabs, and newlines) in the input
file, and there is no concept of precision for the numeric input
conversions as there is for the corresponding output conversions. 
Ordinarily, non-whitespace characters in the template are expected to
match characters in the input stream exactly. 
<a name="index-conversion-specifications-_0028_0040code_007bscanf_007d_0029-707"></a>
When a <dfn>matching failure</dfn> occurs, <code>scanf</code> returns immediately,
leaving the first non-matching character as the next character to be
read from the stream, and <code>scanf</code> returns all the items that were
successfully converted. 
<a name="index-matching-failure_002c-in-_0040code_007bscanf_007d-708"></a>
The formatted input functions are not used as frequently as the
formatted output functions.  Partly, this is because it takes some care
to use them properly.  Another reason is that it is difficult to recover
from a matching error.

   </body></html>


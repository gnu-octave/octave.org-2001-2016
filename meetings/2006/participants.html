<html>
<head><title>Octave 2006 Participants</title></head>
<body>
<h1>Octave 2006 Workshop Participants</h1>
<table>
<tr><th width="150" align="left"><font size=5>Name</a></th><th align="left"><font size=5>Title of presentation</font></th></tr>
<tr><td valign="top">Andy Adler</td><td>Challenges in collaborative scientific open source software: the Electrical Impedance and Diffuse Optical Tomography Reconstruction Software (EIDORS) project</td></tr>
<tr><td>Muthiah Annamalai</td><td><a href="participants.html#Annamalai">Octave-GTK: A GTK binding for GNU Octave</a></td></tr>
<tr><td>David Bateman</td><td><a href="http://arxiv.org/abs/cs.MS/0604006">Sparse matrix implementation in Octave</a></td></tr>
<tr><td>Bill Denney</td><td>Challenges of Octave use in life sciences</td></tr>
<tr><td>John W. Eaton</td><td>Near term features and project management issues</td></tr>
<tr><td valign="top">Dirk Eddelbuettel</td><td><a href="participants.html#Eddelbuettel">Octave and Quantian: Integrating a high-level numerical language into a scientific computing environment</a></td></tr>
<tr><td>Etienne Grossman</td><td>Computer vision tools for Octave</td></tr>
<tr><td>Tom Holroyd</td></tr>
<tr><td>Paul Kienzle</td><td>Model-driven user interface design</td></tr>
<tr><td>Przemek Klosowski</td><td>Implementing units in octave calculations</td></tr>
<tr><td>Laurent Mazet</td><td><a href="http://arxiv.org/abs/cs.MS/0604039">A fixed point type for Octave</a></td></tr>
<tr><td>Mike Miller</td></tr>
<tr><td>Rick Niles</td><td><a href="octave_gis.pdf">Bringing GIS to Octave</a></td></tr>
<tr><td>Jens Ruecknagel</td><td><a href="participants.html#Ruecknagel">Type Estimating Octave to C++ Compiler</a></td></tr>
<tr><td>Alois Schl&ouml;gl</td><td><a href="http://arxiv.org/abs/cs.MS/0603001">BioSig - An application of Octave</a></td></tr>
<tr><td>Robert S. Weigel</td><td>CISM DX</td></tr>
</table>
<hr />
<a name="Annamalai"><h2>Octave-GTK: A GTK binding for GNU Octave</h2></a>
<p>Muthiah Annamalai</p>
<p>Language binding, is a favorite solution for programming language
interoperability problems, that helps extend the reuse of libraries, and
save developer's time, all the same providing new functionality to the
host language.  In this paper, we discuss the problems faced with
interoperability between two programming langauges, with respect to GNU
Octave, and GTK API written in C, to provide the GTK API on Octave as a
part of Octave-GTK, our research project.  Octave-GTK is the fusion of two
different API's exported by GNU Octave [scientific computing tool] and
GTK [GUI toolkit], to use GTK primitives within GNU Octave, to build graphical
front ends, at the same time using Octave engine for number crunching power.
Octave GTK, is a GTK binding for Octave.  The concept of binding is
prevalent in the world of free software, and this paper illustrates our
implementation this technologies, and binding logic.  Also shown, are
methods of code generation, binding automation, and the niche we plan to
fill in the absence of GUI in Octave.  Canonical discussion of advantages,
feasibility and problems faced in the process are elucidated.</p>

<hr />
<a name="Ruecknagel"><h2><a href="http://www.ruena.de/">Type Estimating Octave to C++ Compiler</a></h2></a>
<p>Jens Ruecknagel</p>

<p>In this thesis core techniques for an Octave to C++ compiler are developed. 
Programs written in Octave, an interpreted interactive array language, 
often lack performance and portability. The development of an Octave to 
C++ compiler enables the translation of Octave programs into faster and more 
portable C++ code.</p>

<p>The major challenge in compiling interactive array languages is the 
absence of type declarations. The type declarations, needed for C++, 
have to be extracted from the high level semantic of Octave by using 
type estimation techniques. The extracted type information can than be 
used to replace type-polymorphic but slow Octave operations by fast but 
typed C++ operations.</p>

<p>State of the art type estimation techniques for interactive array 
languages are profoundly explained and evaluated in this thesis. All 
type estimation approaches analyze a source program, until the estimated 
type information stop changing. For an Octave compiler prototype, I 
developed an advanced approach to type estimation. While the conventional 
approach iterates on the whole program, the new approach accelerates type 
estimation by making it data driven, i.e. the type estimator analyzes an 
operation only if the estimated type of its result or its parameters got 
changed. Furthermore the type system of the new approach is adapted to 
fit the special needs of the Octave language. With this newly developed 
type estimation approach, an Octave to C++ compiler can be implemented.</p>

<p>As a proof of concept I implemented an Octave to C++ compiler prototype 
using the newly developed techniques. A first benchmark, which compares 
compiler generated programs with the corresponding interpreted version, 
shows that the compiled code executes on average 38 times faster.</p>

<hr />
<a name="Eddelbuettel"><h2>Octave and Quantian: Integrating a high-level numerical language into a scientific computing environment</h2></a>
<p>Dirk Eddelbuettel</p>
<p>Octave (Eaton, 2001) is a high-level language and a programming environment 
with a primary focus on numerical computations---in particular linear algebra, 
nonlinear and differential equations--that is also highly suitable for 
statistical analysis, visualization, prototyping, scripting, batch processing 
and more. Octave implements a language not unlike that of another leading 
(commercial) brand. The language is highly intuitive: expression 'just like 
the math on the paper' make Octave an excellent choice for use in teaching 
and research. Another strength of Octave is the extensibility using compiled 
C/C++ or Fortran code.</p> 

<p>Quantian (Eddelbuettel, 2003) is a comprehensive scientific computing 
environment that is distributed as a single bootable DVD. With automatic 
configuration of all major hardware aspects (graphics, networking, sound, 
USB interfaces, ...), Quantian can turn any idle desktop or laptop into a 
scientific workstation within minutes. Quantian contains approximately seven 
gigabytes of installed and configured software that is ready for immediate 
use. Quantian has a clear focus on scientific, numerical and quantitative 
applications.</p>

<p>Moreover, Quantian provides openMosix to create single-system image 
clusters of workstations as well as standard parallel computing toolkits 
like PVM and LAM/MPICH. Any machine running Quantian can act as a master 
node from which other nodes can be booted remotely: an entire lab can be 
turned into a computing cluster within minutes.</p>

<p>Quantian has always contained Octave as well as an increasing number 
of additional packages for Octave: octave-epstk, octave-forge, octave-gpc,
octave-plplot, octaviz. We argue that the complete control over the 
installation within the framework of a Quantian image permits for unparallel 
customization. This allows to highlight ever possible aspect of a computing 
system. For example, Quantian contains just about every visualization and 
plotting front-end that can be tied to Octave. This tight coupling and 
predictable configuration makes Quantian an ideal platfom for Octave 
research, demos and distribution.</p>

<p>Quantian draws from from Knoppix and Debian. Time permitting, we may 
also discuss aspects of Octave package maintenance in Debian, its possible 
feedback on Octave development and its role to Quantian development.</p>

</body>
</html>
